---
title: "Building an Instructional Simulation App in Shiny"
author: "Homer White"
date: "June 24, 2015"
output: html_document
runtime: shiny
---

## Introduction and Prerequisites

### Overview

Shiny makes it easy for R users to develop responsive, R-powered web applications.  As you probably know, either from your own initial forays into Shiny or from the <a href = "http://shiny.rstudio.com/tutorial/" target = "_blank">Shiny Tutorial</a>, creating simple apps is no problem, and probably you have some ideas for teaching apps that could be written using just the tools developed in the Tutorial.

But some teaching apps appear to be quite complex.  Consider, for example, <a href = "http://homer.shinyapps.io/SlowGoodness" target = "_blank">this app</a> which aims to introduce the student to the $\chi^2$ Test for Goodness of Fit.  The app takes the user through a simulation process, keeping track of the results of simulations as they accumulate, permitting the viewer to consider the results from several points of view, and allowing the viewer to start over, perhaps with new data.

The aim of this tutorial is to take you step-by-step through the construction of a reasonably full-featured simulation app that lets students explore, through simulation, the coverage properties of the classical t-intervals for a population mean.  After completing the tutorial you will be able to write your own simulation apps---hopefully having been spared some of the struggle that I went through when I first learned Shiny in the Spring of 2014.

### Prerequisites

This tutorial assumes that you have:

* **familiarity with R**.  We'll assume some basic facility in R programming and that you can at least read and understand R code that creates custom plots in R's base graphics system.  For the most part our explanation of R code will be limited to its relationship to app-building.
* **an introductory knowledge of Shiny**.  All necessary prerequisites inthis area can be acquired by watching Garret Grolemund's excellent three-part webinar on *How to Stat with Shiny*.  (See R Studio's <a href = "http://www.rstudio.com/resources/webinars/" target = "_blank">webinars</a> page.)

### Acquiring Source Code

All of the materials for this tutorial are available in my GitHub repository:

><a href = "https://github.com/homerhanumat/shinyTutorials" target = "_blank">https://github.com/homerhanumat/shinyTutorials</a>

The code in the above repository is licensed as fee software:  please feel free to copy and modify it for your own apps.  If you use Git, you could clone the repository into a new R Project.  Otherwise simply visit the repository and click the `Download Zip` button.  You can also offer feedback on GitHub by opening an Issue.

## Version 1:  The Bare-Bones App

### The App

We'll start a very simple confidence-interval app (below).  Play with it until you understand what it does.

```{r, echo=FALSE}
shinyAppDir(
  "example_sim_01/",
  options=list(
    width="100%", height=550
  )
)
```

### Code and Discussion

The complete code may be viewed  <a href = "https://github.com/homerhanumat/shinyTutorials/blob/master/example_sim_01/app.R" target = "_blank">here</a>, but since it's not a great deal of code (yet), we also show it below:

```{r eval = FALSE}
## Initial App

library(shiny)
library(scales) # for transparency in density-plot fill

############################################################
## Set up the gamma-distributed population
###########################################################
shapeGamma <- 2
scaleGamma <- 50
xSkew <- seq(0,shapeGamma*scaleGamma+7.5*sqrt(shapeGamma)*scaleGamma,
             length.out=600)
ySkew <- dgamma(xSkew,shape=shapeGamma,scale=scaleGamma)
popDen <- list(x=xSkew,y=ySkew)
popMean <- shapeGamma*scaleGamma
yMax <- 1.5*max(popDen$y)

############################################################
## ui
############################################################

ui <- fluidPage(
  titlePanel('What Does "Confidence Level" Mean?'),
  sidebarPanel(
    sliderInput(inputId="n","Sample Size n",value=2,min=2,max=50,step=1),
    helpText("How confident do you want to be that the population mean is contained",
             "within the confidence interval?   Use the slider to select a desired",
             "percent-confidence level."),
    sliderInput(inputId="confLevel","Confidence Level",value=80,min=50,max=99,step=1),
    actionButton("takeSample","Sample Now")
    ), # end sidebarPanel
  mainPanel(
    plotOutput("plotSample")
    )  # end mainPanel
  )

#################################################################
## server
#################################################################

server <- function(input, output) {
  
  ## set seed so that users are likely to get different results
  set.seed(as.numeric(Sys.time()))
  
  rv <- reactiveValues(sample = NULL, 
                       mean = NULL, 
                       lower = NULL,
                       upper = NULL)
  
  observeEvent(input$takeSample, 
               {
                 # random sample and its mean
                 samp <- rgamma(input$n,shape=shapeGamma,scale=scaleGamma)
                 xbar <-  mean(samp)
                 # make bounds for the confidence interval
                 conf = isolate(input$confLevel/100)
                 t.input = conf + ((1 - conf)/2)
                 tMultiplier = qt(t.input, df = input$n - 1)
                 se = sd(samp)/sqrt(input$n)
                 margin = tMultiplier * se
                 # store in rv
                 rv$sample <- rgamma(input$n,shape=shapeGamma,scale=scaleGamma)
                 rv$mean <- xbar
                 rv$lower <- xbar - margin
                 rv$upper <- xbar + margin
                 }
               )
  
  
  output$plotSample <- renderPlot({
    # the underlying population
    plot(popDen$x,popDen$y,type="l",lwd=3,col="red",
         main="Density Curve of Population",
         xlab="",
         ylab="density",
         ylim = c(0,yMax))
    abline(v=popMean,lwd=2)
    # sample and interval
    if (input$takeSample) {
      # density plot for the sample
      sampDen <- density(rv$sample, from = 0)
      xdens <- sampDen$x
      ydens <- sampDen$y
      firstx <- xdens[1]
      lastx <- xdens[length(xdens)]
      polygon(x = c(firstx,xdens,lastx), y = c(0,ydens,0), col = alpha("lightblue",0.5))
      # now the interval
      intLevel <- 0.95*yMax
      segments(x0 = rv$lower, y0 = intLevel, x1 = rv$upper, y1 = intLevel, 
               col = "green", lwd = 3)
      text(x=rv$lower,y=intLevel,labels="(")
      text(x=rv$upper,y=intLevel,labels=")")
      points(rv$mean, intLevel, col = "blue", pch = 20,cex=2)
      rug(rv$sample)
      }
    })  # end plotSample
  } # end server

#######################################################
## knit the app
#######################################################

shinyApp(ui = ui, server = server)
```

#### Session vs. User Considertions

The code determining the population is placed outside of the `ui()` and `server()` functions.  This means that it will be run only once, at the beginning of the R session, even if multiple users are viewing the app.  Since in this bare-bones version our users can't pick another population, it's most efficient to run the code once for everyone.

The code to set the random seed:

```{r eval = FALSE}
  set.seed(as.numeric(Sys.time()))
```

appears inside the `ui()` function.  Hence it is run once for each user.  Since users are likely to app at different times, they are all likely to experience different results.  Usually this is what we desire when class members use an app together.

#### Reactive Values, User Input and Observation

When the app begins, the `rv` list is created with the call to `reactiveValues()` and all values in the list are iniatially set to `NULL`.  The user may or may not select a new sample size and confidence level, but since the `rv` values have been set the `renderPlot()` function, having a body that contains these values, is obliged to spring into action and to make `output$plotSample`.  However, before the user requests a sample, the value of the action button, `input$takeSample` is 0.  Hence the `if` clause in `renderPlot()` will evaluate to `FALSE` and the only thing produced is a density plot of the population.

If this app were a rock band, then `reactiveValues()` and `observeEvent()` would surely be the drummer and bass guitar player.  Working together, this pair makes the underlying rhythm and helps the other players stay on track.

Their mutual synergy is evident as soon as the user requests a sample. Requesting a sample entails pressing the action button, which changes the value of `input$takeSample`.  `observeEvent()` takes note of this occurence.  This function:

* runs the code to produce a random sample of the desired size,
* computes a confidence interval of the desired level of confidence, and
* updates `rv` with the relevant information.

Since the elements of `rv` are all reactive, a change in any one of them suffices to invalidate `output$plotSample`.  Hence R runs `renderPlot()` again.  Whenever the user requests a sample, `input$takeSample`, which began at 0, increases by one unit.  Hence in the `if` statement the condition `input$takeSample` will evaluate to `TRUE`---in R, any nonzero integer coerced to a logical value evaluates to `TRUE`---and`renderPlot()` will therefore add the density plot of the sample and the confidence interval to the density plot of the population.

This process will repeat every time the user requests a sample.  Since all positive integers evaluate to `TRUE`, the current sample and confidence interval, as produced by `observeEvent()` and recorded in `rv`, will be added to the population curve.


## Version 2:  Keep Track of Results

### The App

From Version 1 a persistent student could acquire some sense of coverage:  when the confidence level is set high, it will appear that the interval almost always covers the mean, etc.  But surely it would be better for the app to keep track of whether or not the interval covered the mean, and to report those results, in summary form, to the user.  Our second version accomplishes this.

Play with it a little:

```{r, echo=FALSE}
shinyAppDir(
  "example_sim_02/",
  options=list(
    width="100%", height=550
  )
)
```

### Code and Discussion

The complete code may be viewed  <a href = "https://github.com/homerhanumat/shinyTutorials/blob/master/example_sim_02/app.R" target = "_blank">here</a>.  In what follows we'll point out the important additions.

First, note that `rv` contains two new values:  `rv$sims` and `rv$good`.

```{r eval = FALSE}
  rv <- reactiveValues(sample = NULL, 
                       mean = NULL, 
                       lower = NULL,
                       upper = NULL,
                       sims = 0,
                       good = 0)
```

`sims` keep track of the number of samples taken so far, and `good` records the number of those samples for which the interval covered the mean.  The tracking is accomplished in the call to `observeEvent()`:

```{r eval = FALSE}
                 goodInterval <- popMean >= lower & popMean <= upper

                  # ...
                  
                 rv$sims <- rv$sims + 1
                 rv$good <- rv$good + goodInterval
```

We have new output, created by a call to `renderTable()`:

```{r eval = FALSE}
  output$summary <- renderTable({
    df <- data.frame(rv$sims,
                     rv$good,
                     ifelse(rv$sims >0, round(rv$good/rv$sims*100,3), NA))
    names(df) <- c("Simulations", "Good Intervals", "Percentage Good")
    df
    }, include.rownames = FALSE)
```

In the above code, the argument `include,rownames` is being passed to an underlying function `xtable()` that creates a formatted table from the data frame `df`.  Setting `include.rownames` to `FALSE` precludes a useless row number from appearing in that table.

## Version 3:  Conditional Panels

### The App

Version 2 keeps track, but right now that's worse than the memory-less Version 1.  What if the user changes the confidence level?  Then the summarized results don't make any sense.

We also want to study coverage properties for other populations besides the slightly skewed one that is provided for us.  If we were to add such a feature, then it would be wise to allow the app to start afresh.

The new version below addresses two of the above issues by adding a start-over feature and conditionally hiding certain input widgets.

```{r, echo=FALSE}
shinyAppDir(
  "example_sim_03/",
  options=list(
    width="100%", height=550
  )
)
```

### Code and Discussion

You can study the complete code <a href = "https://github.com/homerhanumat/shinyTutorials/blob/master/example_sim_03/app.R" target = "_blank">here</a>.  In what follows we'll discuss how the start-over feature was implemented.

#### Conditional Panels

The crucial Shiny concept here is the concept of a *conditional panel*.  We've got two of them in the sidebar panel, and another in the main panel:

```{r eval = FALSE}
  sidebarPanel(
    conditionalPanel(
      condition = "input.takeSample == 0 || output.beginning == true",
      sliderInput(inputId="n","Sample Size n",value=2,min=2,max=50,step=1),
      helpText("How confident do you want to be that the population mean is contained",
             "within the confidence interval?   Use the slider to select a desired",
             "percent-confidence level."),
     sliderInput(inputId="confLevel","Confidence Level",value=80,min=50,max=99,step=1)
     ),
    actionButton("takeSample","Sample Now"),
    conditionalPanel(
      condition = 'output.beginning == false',
      actionButton("reset","Start Over")
      )
    ), # end sidebarPanel
  mainPanel(
    plotOutput("plotSample"),
    conditionalPanel(
        condition = 'output.beginning == false',
        tableOutput("summary")
        )
```

#### JavaScript Conditions

As a Shiny programmer you can get by without thinking about JavaScript, but conditional panels are an important exception to this general rule.  The `condition` argument takes a JavaScript Boolean expression.  You can build it up with operators that look like those of R, but note that the JavaScript Boolean values are lower case:  `true` and `false`.  Your expression can refer to input and output objects, but you have to use a `.` in place of a `$`:  thus `output.beginning` as opposed to `output$beginning`.  If you want to learn more about Boolean expression in JavaScript, start [here](http://www.w3schools.com/js/js_comparisons.asp).


#### A New Observer

We have a new action button, with value `input$reset`.  Hence there is a corresponding new `rv` value named `rv$begin` that is initially set to `TRUE`:

```{r eval = FALSE}
  rv <- reactiveValues(sample = NULL, 
                       mean = NULL, 
                       lower = NULL,
                       upper = NULL,
                       sims = 0,
                       good = 0,
                       begin = TRUE)
```

Accordingly there is a new observer to perform appropriate updates to `rv` in response to the user's request to start over:

```{r eval = FALSE}
  observeEvent(input$reset,
               {
                 rv$sample <- NULL
                 rv$mean <- NULL
                 rv$lower <- NULL
                 rv$upper <- NULL
                 rv$sims <- 0
                 rv$good <- 0
                 rv$begin <- TRUE
                 }
               )
```

#### Options for Output Suspension

In order for Boolean expressions in conditional panels to be able to express whether or not we are starting over, we need to create the appropriate output object:

```{r eval = FALSE}
  output$beginning <- reactive({
    rv$begin
  })
  
  # needed for the conditional panels to work
  outputOptions(output, 'beginning', suspendWhenHidden=FALSE)
```

The second statement in the code above is immensely important.  Sometimes an output object is being shown to the user (for instance:  a plot in a tab panel that the user has selected), and at other times it may be hidden.  The default behavior of Shniny is to *suspend* an object when it is hidden, meaning that when it is hidden the code to make it won't be run, even if there are changes in values on which that code depends reactively.  Since there is no `...Output()` function in any panel that displays `output$beginning` to the user, this object is always hidden.  Nevertheless, we need it to update whenever `rv$begin` changes value:  in Shiny terms, we don't want this hidden object to be suspended.  `outputOptions()` permits us to force the object to be responsive at all times.

#### Avoid Screen Flashes

You might be curous about the form of the conditonal for the first conditonal panel of the sidebar:

```{r eval = FALSE}
  sidebarPanel(
    conditionalPanel(
      condition = "input.takeSample == 0 || output.beginning == true",
      # ...
```

When the app is first loaded, `output$beginning` has not yet been computed.  Therefore a conditional of the form `output.beginning == true`  would not compute to TRUE, and one would, for a brief moment, see a sidebar that does not include this panel.  As soon as `server` is run the conditional would evaluate to TRUE and the larger "set-up" portion of the panel would appear, but to avoid that annoying screen flash we augmented the conditional to include the element `input.takesample == 0`, which is indeed true at the outset.


#### A Tweak to the `takeSample` Observer

Note finally the addition to the observer of `input$takeSample`:

```{r eval = FALSE}
  observeEvent(input$takeSample, 
               {
                 # ...
                 rv$begin <- FALSE
                 }
               )
```

As soon as a sample is requested the `FALSE` value of `rv$begin` is passed on to `output$beginning, so that the conditional panels will hide "set-up" widgets in the sidebar panel.

Of course we also want to start adding the sample and confidence intervals to our plot.  Hence we also use `rv$begin` to control whether the sample and interval are to be added.  In the call to `renderPlot()` we now find:

```{r eval = FALSE}
    if (! rv$begin) {
      # density plot for the sample
      # ...
      # now the interval
      # ...
      }
```

## Version 4:  Choose Your Population

### The App

The next version (below) permits the user at set-up to choose from four different populations.

```{r echo = FALSE}
shinyAppDir(
  "example_sim_04/",
  options = list(
    width = "100%", height = 600
  )
)
```

### Code and Discussion

You can study the complete code <a href = "https://github.com/homerhanumat/shinyTutorials/blob/master/example_sim_04/" target = "_blank">here</a>:  once again our discussion will highlight new features.

#### Auxiliary Files for Complex Apps

First of all, note that setting up four populations requires a fairly long block of code.  In order to keep the `app.R` as brief and easy-to-scan as possible, we offload population creation to a separate R script (`setup.R`, here stored in the same directory as `app.R`) and source it in at the beginning:

```{r eval = FALSE}
library(shiny)
library(scales) # for transparency in density-plot fill

## Set up underlying populations:
source("setup.R")
```

#### Handling Choice of Population

The crucial addition to `ui` is the following widget:

```{r eval = FALSE}
selectInput(inputId="popDist",label="Population Shape",
                  choices=list("Normal"="normal",
                               "Skewy"="skew",
                               "REALLY Skewed"="superskew",
                               "Way-Out Outlier Group"="outliers"))
```

Note that `selectInput()` appears inside of a conditional panel, in such a way that it is displayed only at the beginning and immediately after a request to start over.

For clarity in code the main panel now consists of two conditional panels:

```{r eval = FALSE}
  mainPanel(
    conditionalPanel(
      condition = "output.beginning == true",
      plotOutput("initialGraph")
      ),
    conditionalPanel(
      condition = 'output.beginning == false',
      plotOutput("plotSample"),
      tableOutput("summary")
        )
    ) # end MainPanel
```

We augment the `rv` list, initializing the new reactive objects to values pertaining to the Normal population option:

```{r eval = FALSE}
  rv <- reactiveValues(
    popDen = normalDen,
    popMean = normalMean,
    popMax = max(normalDen$x),
    popMin = min(normalDen$x),
    yMax = 1.5*max(normalDen$y),
    # ...
    )
```

Of course in `server` we need an observer for `input$popDist`:

```{r eval = FALSE}
  observeEvent(input$popDist,
               {
                 rv$popDen <- switch(input$popDist,
                                     normal=normalDen,
                                     skew=skewDen,
                                     superskew=superSkewDen,
                                     outliers=outlierDen)
                 rv$popMean <- switch(input$popDist,
                                      normal=normalMean,
                                      skew=skewMean,
                                      superskew=superSkewMean,
                                      outliers=outlierMean)
                 rv$popMax <- switch(input$popDist,
                                     normal=max(normalDen$x),
                                     skew=max(skewDen$x),
                                     superskew=max(superSkewDen$x),
                                     outliers=max(outlierDen$x))
                 rv$popMin <- switch(input$popDist,
                                     normal=min(normalDen$x),
                                     skew=min(skewDen$x),
                                     superskew=min(superSkewDen$x),
                                     outliers=min(outlierDen$x))
                 rv$yMax <- switch(input$popDist,
                                   normal=1.5*max(normalDen$y),
                                   skew=1.5*max(skewDen$y),
                                   superskew=1.5*max(superSkewDen$y),
                                   outliers=1.5*max(outlierDen$y))
                 }
               )
```


Other elements of the `server` code are suitably modified to respond to changes in the desired population.


## Version 5:  Choose the Number of Samples

### The App

It's good practice for students to start out with one simulation at a time.  This gives them a chance:

* to distinguish between population and sample, and
* to judge the effect of the distribution of a sample on the location and length of the confidence interval.

Once they get these points, however, they will want to achieve good estimates of the actual level of confidence by taking many, many samples.  The version below affords them such an opportunity.

```{r echo = FALSE}
shinyAppDir(
  "example_sim_05/",
  options=list(
    width="100%", height=800
  )
)
```

### Code and Discussion

You can study the complete code <a href = "https://github.com/homerhanumat/shinyTutorials/blob/master/example_sim_05/" target = "_blank">here</a>:  once again we will highlight new features.

#### Handling "Expensive" Computations

The set-up version of the sidebar panel has a new input widget:

```{r eval = FALSE}
    helpText("How many samples would you like to take at one time?  Limit is 10000. With each ",
             "sample, we'll make a confidence interval for the population mean."),
    numericInput("sims", "Number of Samples at Once", 1, min=0, max = simLimit, step=1)
```

Since the user can request as many as ten thousand samples at once, it would be wise to spend some space in order to save time in drawing and working with all these samples.  Rather than writing a `for` loop, we choose to draw all needed random items at once and to store them in a matrix, which we then manipulate.  This is accomplished in the new version of the observer of `input$takeSample`:

```{r eval = FALSE}
  observeEvent(input$takeSample, 
               {
                 # get the samples, make the intervals
                 n <- input$n
                 reps <- min(input$sims, simLimit)
                 # grab all the random items you need at once:
                 itemNumb <- reps*n
                 sampleItems <- switch(input$popDist,
                                       normal=rnorm(itemNumb,mean=muNorm,sd=sigmaNorm),
                                       skew=rgamma(itemNumb,shape=shapeGamma,scale=scaleGamma),
                                       superskew=rpareto(itemNumb,alpha=alphaPareto,theta=thetaPareto),
                                       outliers=routlier(itemNumb))
                 # arrange the random items in a matrix; the rows are your samples
                 sampleMatrix <- matrix(sampleItems,ncol=n,nrow=reps)
                 conf = input$confLevel/100
                 t.input = conf + ((1 - conf)/2)
                 tMultiplier = qt(t.input, df = n - 1)
                 # from the matrix, quickly compute the items you need
                 xbar <- rowSums(sampleMatrix)/n
                 se <- sqrt((rowSums(sampleMatrix^2)-n*xbar^2)/(n^2-n))
                 margin = tMultiplier * se
                 lower <- xbar - margin
                 upper <- xbar + margin
                 goodInterval <- ((rv$popMean > lower) & (rv$popMean < upper))
                 goodCount <- sum(goodInterval)
                 latestSamp <<- sampleMatrix[reps,]
                 # store in rv
                 rv$sample <- sampleMatrix[reps, ]
                 rv$mean <- xbar[reps]
                 rv$lower <- lower[reps]
                 rv$upper <- upper[reps]
                 rv$sims <- rv$sims + reps
                 rv$good <- rv$good + goodCount
                 rv$begin <- FALSE
                 })
```

Note that in the code above only the last sample (the final row in the matrix), is passed to `rv$sample`:

```{r eval = FALSE}
                 rv$sample <- sampleMatrix[reps, ]
```

Thus the plot shows only the most recent sample.

#### Adding Explanations for the User

We have also added, to the conditional panel that contains the plot of the population with sample, a list of clarifying remarks:

```{r eval = FALSE}
    conditionalPanel(
      condition = 'output.beginning == false',
      plotOutput("plotSample"),
      HTML("<ul>
                <li>The population density curve is in red.</li>
                <li>The vertical line marks the population mean.</li>
                <li>A density plot for the most recent sample is in light blue.</li>
                <li>The most recent sample mean is the big blue dot.</li>
                <li>The most recent confidence interval is in green.</li>
              </ul>"),
      br(''),
      tableOutput("summary")
      )
```

The more complex the app becomes, the more you want to give the user in the way of explanation.


## Version 6:  Tabset Panels

### The App

Suppose that our students are told about how t-interval are made from the t-statistic.  Then they are liable to have been told as well about how the nominal levels of confidence for t-interval are derived from quantiles of the relevant t-curve, that the nominal and actual levels of confidence are the same provided that the t-statistic has exactly a t-curve distribution, and that departures from normality in the population therefore are liable to result in differences between the nominal and actual levels of confidence.

In order to reduce (somewhat) the probability that such theory-talk will be discounted entirely by students, we could opt to look at our app-results from a new point of view:  we could compare the "theoretical" t-curve with a density plot of the t-statistics associated with each of the samples that have been taken so far.  The next version of the app (below), implements this comparison.

```{r echo = FALSE}
shinyAppDir(
  "example_sim_06/",
  options=list(
    width="100%", height=800
  )
)
```

### Code and Discussion.

You can study the complete code <a href = "https://github.com/homerhanumat/shinyTutorials/blob/master/example_sim_06/" target = "_blank">here</a>:  once again our discussion will highlight new features.

In the `ui`, the main panel now contains conditional panel that takes the form of a tab-set:

```{r eval = FALSE}
    conditionalPanel(
      condition = "output.beginning == false",
      tabsetPanel(
        tabPanel(title = "Latest Interval",
                 plotOutput("plotSample"),
                 HTML("<p> </p>"),
                 HTML("<ul>
                        <li>The population density curve is in red.</li>
                        <li>The vertical line marks the population mean.</li>
                        <li>A density plot for the sample is in light blue.</li>
                        <li>The sample mean is the big blue dot.</li>
                        <li>The confidence interval is in green.</li>
                      </ul>"),
                br(''),
                tableOutput("summary")
                ),
        tabPanel(title = "t-statistic",
                 plotOutput("tstatistic"),
                 HTML(
                   "<p>The plots above compare the actual distribution of the t-statistic
                      to the t-curve with n-1 degrees of freedom.</p>
                    <p></p>
                    <ul>
                      <li>The t-curve is in red.  If the population is exactly normal, 
                        then this curve represents the exact distribution of the t-statistic.</li>
                      <li>The density plot of the t-statistics found so far is shown in blue.  
                          This plot gives a pretty good estimate of the actual distribution of the                                    t-statistic, for the population and sample size that you have selected.</li>
                    </ul>")
                 )
        ) # end tabset panel
      ) # end conditonal panel
```

Naturally, we augment `rv` with a value to record the t-statistics that have will be computed:

```{r eval = FALSE}
  rv <- reactiveValues(
    # ...
    tstats = numeric())
```

We add to `rv$tstats` in the observer of `input$takesSample`:

```{r eval = FALSE}
observeEvent(input$takeSample, 
               {
                 # ...
                 rv$tstats <- c(rv$tstats, (xbar-rv$popMean)/se)
               })
```

The observer of `input$reset` is also modified:

```{r eval = FALSE}
  observeEvent(input$reset,
               {
                 # ...
                 rv$tstats <- numeric()
               })
```

The code that produces the t-statistic density plot requires careful choice of band-width in order to produce reasonably informative plots when very few samples have been taken:

```{r eval = FALSE}
  output$tstatistic <- renderPlot({
    input$takeSample
    n <- input$n
    numberSims <- rv$sims
    tstats <- rv$tstats
    if (numberSims == 1) {
      tstatDen <- density(tstats,n=1024,from=-10,to=10,bw=1)
      }
    if (numberSims >= 2 && n < 5) {
      tstatDen <- density(tstats,n=1024,from=-10,to=10,bw=0.1)
      }
    if (numberSims >= 2 && n >= 5) {
      tstatDen <- density(tstats,n=1024,from=-10,to=10,bw="SJ")
      }
    if (numberSims > 0) {
      ymax <- max(tstatDen$y,dt(0,df=n-1))
      plot(tstatDen$x,tstatDen$y,type="l",lwd=2,col="blue",
           main="t-statistic vs. t-curve",cex.main=2,
           xlab="t", ylim=c(0,ymax),xlim=c(-6,6),
           ylab="density")
      curve(dt(x,df=n-1),-6,6,col="red",lwd=2,add=TRUE)
      } #end check that there are samples
  })
```



## Version 7:  Incorporate a Related App

### The App

Could the user learn something by viewing several confidence intervals at once?  The app below provides such an option.  It also adds a tab containing information about the app.

```{r echo = FALSE}
shinyAppDir(
  "example_sim_07/",
  options=list(
    width="100%", height=800
  )
)
```

If you wish you may also view this final version in isolation on the <a href = "http://homer.shinyapps.io/example_sim_07" target = "_blank">Web</a>.

### Code and Discussion

You can study the complete code <a href = "https://github.com/homerhanumat/shinyTutorials/blob/master/example_sim_07/" target = "_blank">here</a>:  once again our discussion will highlight new features.

#### Adding the Related App

When you examine the file structure of the source code on GitHub, you will notice that we have switched from single-file format(`app.R`) to the older two-file format (`ui.R` and `server.R`).  It's good to do this as your code gets longer.

The overall structure of the user interface is provided by `navbarPage()`:

```{r eval = FALSE}
navbarPage(
  title = 'Exploring Confidence Intervals',
  tabPanel(title = "Coverage Properties",
           #...
           ),
           mainPanel(
             conditionalPanel(
               condition = "input.takeSample == 0 || output.beginning == true",
               # ...
               ),
             conditionalPanel(
               condition = "output.beginning == false",
               tabsetPanel(
                 id = "coverageTabsetPanel",
                 tabPanel(
                   title = "Latest Interval",
                   # ...
                   ),
                 tabPanel(
                   title = "t-statistic",
                   # ...
                   )
                 )
               )
             )
           ),
  tabPanel(
    title = "Fifty at a Time",
    sidebarPanel(
      conditionalPanel(
        condition = "input.takeSample2 == 0 || output.beginning2 == true",
        selectInput(
          inputId="popDist2",
          label="Population Shape",
          choices=list("Normal"="normal",
                       "Skewy"="skew",
                       "REALLY Skewed"="superskew",
                       "Way-Out Outlier Group"="outliers")
          ),
        br()
        ),
      sliderInput(inputId="n2","Sample Size n",value=2,min=2,max=50,step=1),
      helpText("How confident do you want to be that the population mean is contained",
               "within the confidence interval?   Use the slider to select a desired",
               "percent-confidence level."),
      sliderInput(inputId="confLevel2","Confidence Level",value=80,min=50,max=99,step=1),
      actionButton("takeSample2","Fifty Samples Now"),
      conditionalPanel(
        condition = 'output.beginning2 == false',
        actionButton("reset2","Start Over")
        )
      ),
    mainPanel(
      conditionalPanel(
        condition = "input.takeSample2 == 0 || output.beginning2 == true",
        plotOutput("initialGraph2"),
        HTML("<ul>
                <li>The population density curve is in red.</li>
                <li>The vertical line marks the population mean.</li>
             </ul>")
        ),
      conditionalPanel(
        condition = "output.beginning2 == false",
          plotOutput("plotSample2"),
          HTML("<ul>
                  <li>The population density curve is in red.</li>
                  <li>The vertical line marks the population mean.</li>
                  <li>Intervals covering the mean are green.</li>
                  <li>Intervals NOT covering the mean are in burlywood.</li>
               </ul>"),
          tableOutput("summary2")
        )
      )
    ),
  navbarMenu(
    title = "More",
    tabPanel(
      title = "Help",
      includeHTML("infoFiles/help.html")
      ),
    tabPanel(
      title = "About",
      includeHTML("infoFiles/aboutapp.html")
      )
    )
  )
```


The aim is to make the "fifty-at-a-time" app function independently of the original "coverage properties" app.  Accordingly it requires its own set of inputs and outputs:  hence the considerable increase in the amount of code.

#### Adding HTML Files

Note also that two informational HTML files appear in their own subdirectory `infoFiles`.  This is done because they are each being generated by corresponding R Markdown files (`help.Rmd` and `aboutapp.Rmd`)  Since Shiny servers can host R Markdown documents and are therefore disposed to look for them in the root directory, the R Markdown files should not appear at the root level.

#### Updating Values on the User

One minor new feature of this verison is worthy of note.  In the observer to `input$takeSample` we now find:

```{r eval = FALSE}
observeEvent(
    input$takeSample, 
    {
    # if user is at the beginning or has started over, and one sample at a time is
    # requested, then we will assume that the user would prefer to stat on the "Latest Interval"
    # tabPanel, rather than the "t-statistic" tabPanel.  Assure this:
    if (rv$begin && input$sims == 1) {
      updateTabsetPanel(session, "coverageTabsetPanel", selected = "Latest Interval")
      }
    # ...
    }
    )
```

Shiny has a number of `update...()` functions that can selectively change values on a user.  In the code above, the update makes sure that when the user is at the beginning of a simulation process and is requesting only one sample at a time, then he or she will, upon request of the sample, be shown the "Latest Interval" tab panel, even if he or she had most recently selected the "t-statistic" panel.

If you want to use an `update...()` function, make sure to include `session` as an argument to the `server` function:


```{r eval = FALSE}
function(input, output, session) {
  # body of server function
}
```


**Note**:  I have found that in order for the current version of Shiny (0.12.1) to heed this function, the titles for the separate tab panels in the tabset have to be provided explicity:

```{r eval = FALSE}
              tabsetPanel(
                 id = "coverageTabsetPanel",
                 tabPanel(
                   title = "Latest Interval",
                   # ...
                   ),
                 tabPanel(
                   title = "t-statistic",
                   # ...
                   )
                 )
```

As far the panels themselves are convered, their title can be recognized by R's positional matching of arguments:

```{r eval = FALSE}
              tabsetPanel(
                 id = "coverageTabsetPanel",
                 tabPanel(
                   "Latest Interval", # comes first, so assigned to argument 'title'
                   # ...
                   ),
                 tabPanel(
                   "t-statistic",  # comes first, so assigned to argument 'title'
                   # ...
                   )
                 )
```


For some reason, however, this won't suffice for `updateTabsetPanel()` to work.

## Time to Stop

By now the app has gotten become fairly flexible and informative.  Still I'm sure that you can think of a few extra bells and whistles to add.  If you teach bootstrap intervals, you might might want to incorporate the app into them somehow (or do away with the old-fashioned t-interval entirely).  You are welcome to proceed as you wish.  My intent has not been to create One App to Rule Them All, but rather to persuade you that you can design a better app on your own, without much more in the way of programming skills than the R knowledge that you already possess.


## Cautions, and Further Resources

### Caution:  Output Objects Do Not Bilocate

Sometimes you want the same output to appear in two or more places in your app.  Suppose, for instance, that you want to show a contingency table on two different tab panels in a tab set.  You might try something like this:

```{r echo = FALSE}
library(shiny)

ui <- fluidPage(
  titlePanel('Sorry, No Bilocation!'),
  mainPanel(
    tabsetPanel(
      tabPanel(title = "Panel 1",
        tableOutput("crosstab")
        ),
      tabPanel(title = "Panel 2",
          tableOutput("crosstab")
        )
    )
  )
)

server <- function(input, output) {
  
  output$crosstab <- renderTable({
    xtabs(~ am + cyl, data = mtcars)
  })
  
}

shinyApp(ui = ui, server = server)
```

The result will be:

```{r eval = FALSE}
shinyAppDir(
  "repeating_output/",
  options=list(
    width="100%", height= 200
  )
)
```

The table fails to show in *both* panels!

To rectify this, you have to create distinct output objects.  If your objects require a lot of code, it's wise follow the DRY (Do not Repeat Yourself), and look for a way to put some of that code into a separate function, which is then called in the code that creates the objects.  In our small example, the DRY approach might look like this:

```{r eval = FALSE}
library(shiny)

ui <- fluidPage(
  titlePanel('DRY Bilocation'),
  mainPanel(
    tabsetPanel(
      tabPanel(title = "Panel 1",
        tableOutput("crosstab")
        ),
      tabPanel(title = "Panel 2",
          tableOutput("crosstab2")
        )
    )
  )
)
  
server <- function(input, output) {
  
  makeTable <- function() {
      xtabs(~ am + cyl, data = mtcars)
    }
    
    output$crosstab <- renderTable({
      makeTable()
    })
    
    output$crosstab2 <- renderTable({
      makeTable()
    })
  
}

shinyApp(ui = ui, server = server)
```

Now things work out:

```{r echo = FALSE}
shinyAppDir(
  "dry_bilocation/",
  options=list(
    width="100%", height= 250
  )
)
```

### Caution:  Colliding CSS in Included HTML

The About and Help files in the final version of the app were generated from R Markdown sources.  The default CSS styling for such documents is a version of Bootstrap, whihc can sometimes conflict with the Bootstrap CSS of the app itself, with bizarre results.  If your app doesn't look right after inclusion of such an HTML file, simply remove the styling from the inlcuded file.  This can be done most conveniently in the R Markdown `yaml` front matter, e.g.:

```{r eval = FALSE}
---
title: "About this App"
author: "Homer White"
date: "June 24, 2015"
output: 
  html_document:
    theme:  null
---
```


### Further Resources

#### R Studio Resources

R Studio provides excellent, up-to-date documentation on Shiny in a series of <a href = "http://shiny.rstudio.com/articles/" target = "_blank">articles</a>.  Every single one of them is worth reading.  You will also find yourself consulting their <a href = "http://shiny.rstudio.com/reference/shiny/latest/" target = "_blank">function reference</a>.  Finally, the <a href = "http://shiny.rstudio.com/gallery/" target = "_blank">gallery</a> is an excellent source of inspiration (and code to copy and modify).

#### shinyjs

<a href = "http://deanattali.com/" target = "_blank">Dean Attali</a> is the author of the `shinyjs` package, a collection of useful add-on functions.  Instructors may be especially interested in:

* the `show`, `hide` and `toggle` functions.  They come with options for animation, and so allow you to gently disclose or hide various items such as input widgets.
* the `info` function, to provide a helpful pop-up message.

Dean also has some useful tutorials in the form of blog posts.  See especially:

* <a href = "http://deanattali.com/2015/06/14/mimicking-google-form-shiny/" target = "_blank">Mimicking a Google Form with a Shiny App</a>;
* <a href = "http://deanattali.com/2015/05/09/setup-rstudio-shiny-server-digital-ocean/" target = "_blank">How to get your very own RStudio Server and Shiny Server with DigitalOcean</a>.  If you run your own Shiny Server at your institution, this post contains great IT advice on how to make Shiny apps run as desired.

#### Some of My Other Teaching Apps

As you move beyond simulation apps you will want to incorporate other Shiny capabilities.  Feel free to consult my <a href = "https://github.com/homerhanumat/shinyGC" target = "_blank">Shiny-app repostitory on GitHub</a>, but be aware that the code in most of the apps begs for re-factoring.  You might begin with <a href = "https://github.com/homerhanumat/shinyGC/FindRegLine" target = "_blank">FindRegLine</a>, which illustrates writing student results to a data file so that students can compare their performance to that of other members of the class.

